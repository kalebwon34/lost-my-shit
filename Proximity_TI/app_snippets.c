/**********************************************************************************************
 * Filename:       app_snippets.c
 *
 * Description:    This file contains snippets needed to utilize the generated services.
 *
 *                 Generated by:
 *                 BDS version: 1.0.2116.0
 *                 Plugin:      Texas Instruments CC26xx BLE SDK v2.1 GATT Server plugin 1.0.5 beta
 *                 Time:        Mon Jun 13 2016 10:49:18 GMT+03:00
 *
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *************************************************************************************************/
//...
#include <ti/sysbios/knl/Semaphore.h>
#include <ti/sysbios/knl/Queue.h>

//...
#include "Link_Loss.h"
#include "Immediate_Alert.h"
#include "Tx_Power.h"
#include "Battery_Service.h"

//...

// Semaphore globally used to post events to the application thread
static ICall_Semaphore sem; // Already present in sample applications.

// Queue object used for service messages.
static Queue_Struct serviceMsgQ;
static Queue_Handle hServiceMsgQ;

// Struct for messages from a service
typedef struct
{
  Queue_Elem _elem;
  uint16_t svcUUID;
  uint16_t dataLen;
  uint8_t  paramID;
  uint8_t  data[]; // Flexible array member, extended to malloc - sizeof(.)
} server_char_write_t;

//...

// Declaration of service callback handlers
static void user_LinkLoss_ValueChangeCB(uint8_t paramID); // Callback from the service.
static void user_LinkLoss_ValueChangeDispatchHandler(server_char_write_t *pWrite); // Local handler called from the Task context of this task.
static void user_ImmediateAlert_ValueChangeCB(uint8_t paramID); // Callback from the service.
static void user_ImmediateAlert_ValueChangeDispatchHandler(server_char_write_t *pWrite); // Local handler called from the Task context of this task.
// Tx_Power has no writeable characteristics
// Battery_Service has no writeable characteristics

// Service callback structure
// LinkLoss callback handler. The type Link_LossCBs_t is defined in Link_Loss.h
static LinkLossCBs_t user_Link_LossCBs =
{
  user_LinkLoss_ValueChangeCB // Characteristic value change callback handler
};
// ImmediateAlert callback handler. The type Immediate_AlertCBs_t is defined in Immediate_Alert.h
static ImmediateAlertCBs_t user_Immediate_AlertCBs =
{
  user_ImmediateAlert_ValueChangeCB // Characteristic value change callback handler
};
// Tx_Power has no writeable characteristics.
// Battery_Service has no writeable characteristics.


// taskFxn_init(..)
// {
  // Initialize queue for service messages.
  // Note: Used to transfer control to application thread
  Queue_construct(&serviceMsgQ, NULL);
  hServiceMsgQ = Queue_handle(&serviceMsgQ);

  LinkLoss_AddService();
  LinkLoss_RegisterAppCBs(&user_Link_LossCBs);
  ImmediateAlert_AddService();
  ImmediateAlert_RegisterAppCBs(&user_Immediate_AlertCBs);
  TxPower_AddService();
  BatteryService_AddService();

  // Placeholder variable for characteristic intialization
  uint8_t someVal[20] = {0};

  // Initalization of characteristics in Link_Loss that are readable.
  LinkLoss_SetParameter(LL_ALERT_LEVEL_ID, LL_ALERT_LEVEL_LEN, &someVal);

  // Initalization of characteristics in Immediate_Alert that are readable.

  // Initalization of characteristics in Tx_Power that are readable.
  TxPower_SetParameter(TP_TX_POWER_LEVEL_ID, TP_TX_POWER_LEVEL_LEN, &someVal);

  // Initalization of characteristics in Battery_Service that are readable.
  BatteryService_SetParameter(BS_BATTERY_LEVEL_ID, BS_BATTERY_LEVEL_LEN, &someVal);

//}


// taskFxn(..)
// {
//   for (;;) {
//     ... ICall_wait(...)   // Wait for semaphore post
// 
      // Process messages sent from another task or another context.
      while (!Queue_empty(hServiceMsgQ))
      {
        server_char_write_t *pWrite = Queue_dequeue(hServiceMsgQ);

        switch(pWrite->svcUUID)
        {
          case LINK_LOSS_SERV_UUID:
            user_LinkLoss_ValueChangeDispatchHandler(pWrite);
            break;
          case IMMEDIATE_ALERT_SERV_UUID:
            user_ImmediateAlert_ValueChangeDispatchHandler(pWrite);
            break;
        }

        // Free the message received from the service callback.
        ICall_free(pWrite);
      }

//   }
// }


/**
 * Handle received write that was sent as message to the application task.
 */
void user_LinkLoss_ValueChangeDispatchHandler(server_char_write_t *pWrite)
{
  switch (pWrite->paramID)
  {
    case LL_ALERT_LEVEL_ID:
      // Do something useful with pWrite->data here
      // -------------------------
      break;
  }

}

/**
 * Handle received write that was sent as message to the application task.
 */
void user_ImmediateAlert_ValueChangeDispatchHandler(server_char_write_t *pWrite)
{
  switch (pWrite->paramID)
  {
    case IA_ALERT_LEVEL_ID:
      // Do something useful with pWrite->data here
      // -------------------------
      break;
  }

}


/**
 * Callback handler from the service to application when something is written
 * to a writeable characteristic, called from Stack task context.
 */
static void user_LinkLoss_ValueChangeCB(uint8_t paramID)
{
  // See Link_Loss.h to compare paramID with characteristic value attribute.
  // Called in Stack Task context, so can't do processing here.

  // Send message to application message queue about received data.
  uint16_t readLen = 0; // How much to read via service API
  
  switch (paramID)
  {
    case LL_ALERT_LEVEL_ID:
      readLen = LL_ALERT_LEVEL_LEN;
      break;
  }

  // Allocate memory for the message.
  // Note: The pWrite message doesn't have to contain the data itself, as that's stored in
  //       a variable in the service. However, to prevent data loss if a new value is received
  //       before GetParameter is called, we call GetParameter now.
  // Note: It could be just as well to send dataLen and a pointer to the received data directly to this callback, avoiding GetParameter alltogether.
  server_char_write_t *pWrite = ICall_malloc(sizeof(server_char_write_t) + readLen);

  if (pWrite != NULL)
  {
    pWrite->svcUUID = LINK_LOSS_SERV_UUID;
    pWrite->paramID = paramID;
    // Get the data from the service API. readLen is now equal to allocated space.
    LinkLoss_GetParameter( paramID, &readLen, pWrite->data );
    pWrite->dataLen = readLen; // Store length of received data after GetParameter updates readLen.
    // Enqueue the message using pointer to queue node element.
    Queue_enqueue(hServiceMsgQ, &pWrite->_elem);
    // Let application know there's a message
    Semaphore_post(sem);
  }
}

/**
 * Callback handler from the service to application when something is written
 * to a writeable characteristic, called from Stack task context.
 */
static void user_ImmediateAlert_ValueChangeCB(uint8_t paramID)
{
  // See Immediate_Alert.h to compare paramID with characteristic value attribute.
  // Called in Stack Task context, so can't do processing here.

  // Send message to application message queue about received data.
  uint16_t readLen = 0; // How much to read via service API
  
  switch (paramID)
  {
    case IA_ALERT_LEVEL_ID:
      readLen = IA_ALERT_LEVEL_LEN;
      break;
  }

  // Allocate memory for the message.
  // Note: The pWrite message doesn't have to contain the data itself, as that's stored in
  //       a variable in the service. However, to prevent data loss if a new value is received
  //       before GetParameter is called, we call GetParameter now.
  // Note: It could be just as well to send dataLen and a pointer to the received data directly to this callback, avoiding GetParameter alltogether.
  server_char_write_t *pWrite = ICall_malloc(sizeof(server_char_write_t) + readLen);

  if (pWrite != NULL)
  {
    pWrite->svcUUID = IMMEDIATE_ALERT_SERV_UUID;
    pWrite->paramID = paramID;
    // Get the data from the service API. readLen is now equal to allocated space.
    ImmediateAlert_GetParameter( paramID, &readLen, pWrite->data );
    pWrite->dataLen = readLen; // Store length of received data after GetParameter updates readLen.
    // Enqueue the message using pointer to queue node element.
    Queue_enqueue(hServiceMsgQ, &pWrite->_elem);
    // Let application know there's a message
    Semaphore_post(sem);
  }
}
